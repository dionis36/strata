# üìÑ ARTIFACT #2 ‚Äî Canonical AST JSON Schema

`/docs/SCHEMA_AST_CANONICAL.md`

---

# 1Ô∏è‚É£ Design Principles (Before the Schema)

This schema must:

1. Be language-aware but not language-dependent
2. Support graph construction directly
3. Support DB detection
4. Support risk scoring
5. Support extraction analysis
6. Be forward-compatible
7. Be stable even if AST internals change

Therefore:

* Every array must exist even if empty
* Every node must have a stable ID
* Line numbers must always be present
* File-level and component-level metadata must be separated
* All dependency relationships must be explicit

---

# 2Ô∏è‚É£ Canonical AST JSON Structure (Final Version)

```json
{
  "schema_version": "1.0",
  "analysis_timestamp": "ISO-8601",

  "file": {
    "path": "string",
    "absolute_path": "string",
    "size_bytes": 0,
    "last_modified": "ISO-8601",
    "php_version_detected": "string|null",
    "hash_sha256": "string"
  },

  "components": [
    {
      "component_id": "string", 
      "type": "class|interface|trait|function",
      "name": "string",
      "namespace": "string|null",
      "fully_qualified_name": "string",

      "extends": ["string"],
      "implements": ["string"],
      "uses_traits": ["string"],

      "visibility": "public|protected|private|null",
      "is_abstract": false,
      "is_final": false,
      "is_static": false,

      "signature": "string|null",
      "parameters": [
        {
          "name": "string",
          "type": "string|null",
          "default": "string|null"
        }
      ],

      "return_type": "string|null",

      "location": {
        "start_line": 0,
        "end_line": 0
      },

      "metrics": {
        "loc": 0,
        "cyclomatic_complexity": 0,
        "nesting_depth": 0
      },

      "dependencies": {
        "calls": ["string"],
        "instantiates": ["string"],
        "imports": ["string"],
        "includes": ["string"],
        "global_variables_used": ["string"]
      },

      "database_access": [
        {
          "access_id": "string",
          "type": "raw_sql|pdo|mysqli|orm|unknown",
          "line": 0,
          "query_snippet": "string",
          "tables": ["string"],
          "operation": "SELECT|INSERT|UPDATE|DELETE|UNKNOWN"
        }
      ]
    }
  ],

  "file_level_dependencies": {
    "includes": ["string"],
    "requires": ["string"]
  },

  "file_level_database_access": [
    {
      "access_id": "string",
      "type": "raw_sql|pdo|mysqli|orm|unknown",
      "line": 0,
      "query_snippet": "string",
      "tables": ["string"],
      "operation": "SELECT|INSERT|UPDATE|DELETE|UNKNOWN"
    }
  ]
}
```

---

# 3Ô∏è‚É£ Critical Explanation of Each Section

Now we justify every field ‚Äî because unnecessary fields are dangerous.

---

## üîπ schema_version

Why:

* Future-proofing.
* Allows migration logic.
* Prevents breaking older analysis artifacts.

Never remove.

---

## üîπ analysis_timestamp

Why:

* Required for reproducibility.
* Needed for comparing runs.
* Supports performance benchmarking.

---

## üîπ file block

Why separate file metadata from components?

Because:

* File is a graph node.
* Component is a sub-node.
* Extraction might operate at file level OR component level.

Critical fields:

| Field                | Why                              |
| -------------------- | -------------------------------- |
| path                 | Relative graph identity          |
| absolute_path        | Execution traceability           |
| size_bytes           | Effort estimation                |
| last_modified        | Cache invalidation               |
| php_version_detected | Compatibility tracking           |
| hash_sha256          | Deduplication + change detection |

---

## üîπ components array

This is the heart.

Every class, function, interface, trait becomes a component.

### component_id (CRITICAL)

Must be stable and deterministic.

Recommended:

```
sha256(file_path + fully_qualified_name + start_line)
```

Why:

* Prevent collisions
* Stable across runs unless code changes
* Required for graph edges

---

## üîπ location

Non-negotiable.

Used for:

* Visualization
* Snippet extraction
* Effort scoring
* Refactoring simulation

---

## üîπ metrics block

These are not AST-native ‚Äî but extracted during flattening.

Keep minimal:

* LOC
* Cyclomatic complexity
* Nesting depth

These directly influence:

* Risk score
* Extraction effort

Do NOT over-engineer metrics yet.

---

## üîπ dependencies block

Separated by type for clarity.

Why not a flat list?

Because later you may weight:

* calls differently from includes
* instantiations differently from imports

This enables weighted graph edges.

---

## üîπ database_access block

This is one of your differentiators.

Each access must include:

| Field         | Why                        |
| ------------- | -------------------------- |
| type          | DB risk classification     |
| line          | Traceability               |
| query_snippet | Validation                 |
| tables        | Hotspot detection          |
| operation     | Write vs read risk scoring |

---

## üîπ file_level_database_access

Some legacy code has SQL outside functions.

We must support that.

---

# 4Ô∏è‚É£ Design Decisions That Prevent Future Breakage

### ‚úî Every array exists even if empty

Never omit keys.

### ‚úî All strings must be explicit

No null implicit structures.

### ‚úî No nested AST trees

We flatten ‚Äî we don‚Äôt replicate nikic‚Äôs AST structure.

### ‚úî No raw PHP nodes in output

Output must be language-agnostic JSON.

---

# 5Ô∏è‚É£ What This Schema Enables Immediately

From this single artifact, you can:

* Build dependency graph
* Build DB hotspot map
* Compute centrality
* Compute extraction score
* Compute blast radius
* Simulate node removal
* Generate OpenAPI stub (later)
* Export CSV reports
* Store in relational DB

This is why this is your most critical artifact.

---

# 6Ô∏è‚É£ Critical Weaknesses / Known Limitations

Be honest academically:

* Dynamic includes won‚Äôt be fully captured
* Eval() cannot be statically resolved
* SQL table detection from strings is heuristic-based
* ORM inference may miss implicit queries
* Cyclomatic complexity estimation from AST is approximate

These go in your evaluation chapter later.

