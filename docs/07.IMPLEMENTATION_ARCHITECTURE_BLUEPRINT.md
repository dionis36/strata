# ğŸ“„ ARTIFACT #7 â€” Implementation Architecture & Module Separation Blueprint

Save as:
`/docs/IMPLEMENTATION_ARCHITECTURE_BLUEPRINT.md`

---

# 1ï¸âƒ£ Architectural Philosophy

We enforce:

* Separation of concerns
* One-directional dependency flow
* Testability at every layer
* Replaceable components
* Deterministic execution

We use a **Layered Clean Architecture (adapted for local tool)**.

---

# 2ï¸âƒ£ High-Level Layer Model

We define 5 strict layers:

```
UI Layer (Streamlit)
        â†“
API Layer (FastAPI)
        â†“
Application Layer (Orchestrators / Use Cases)
        â†“
Domain Layer (Graph + Scoring Logic)
        â†“
Infrastructure Layer (Persistence, PHP bridge, filesystem)
```

Critical Rule:

> Dependencies only flow downward.

No lower layer may import a higher layer.

---

# 3ï¸âƒ£ Folder Structure (Strict)

```id="arch01"
project_root/
â”‚
â”œâ”€â”€ frontend/
â”‚   â””â”€â”€ app.py
â”‚
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ main.py
â”‚
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ analysis_service.py
â”‚   â”œâ”€â”€ simulation_service.py
â”‚   â””â”€â”€ export_service.py
â”‚
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ node.py
â”‚   â”‚   â”œâ”€â”€ edge.py
â”‚   â”‚   â””â”€â”€ graph_model.py
â”‚   â”‚
â”‚   â”œâ”€â”€ scoring/
â”‚   â”‚   â”œâ”€â”€ risk_calculator.py
â”‚   â”‚   â””â”€â”€ extraction_calculator.py
â”‚   â”‚
â”‚   â””â”€â”€ algorithms/
â”‚       â”œâ”€â”€ centrality.py
â”‚       â””â”€â”€ blast_radius.py
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ parser_bridge.py
â”‚   â”œâ”€â”€ persistence/
â”‚   â”‚   â”œâ”€â”€ database.py
â”‚   â”‚   â”œâ”€â”€ repositories.py
â”‚   â”‚   â””â”€â”€ migrations.py
â”‚   â”œâ”€â”€ file_scanner.py
â”‚   â””â”€â”€ config.py
â”‚
â”œâ”€â”€ tests/
â”‚
â””â”€â”€ docs/
```

This is not optional.

---

# 4ï¸âƒ£ Layer Responsibilities

---

## ğŸ”¹ 4.1 UI Layer (frontend/)

Responsibilities:

* Display graphs
* Trigger analysis
* Show ranking tables
* Show simulation results

Forbidden:

* Direct graph manipulation
* Risk computation
* File scanning
* DB access

It only calls API.

---

## ğŸ”¹ 4.2 API Layer (api/)

Responsibilities:

* Define endpoints
* Validate request schemas
* Return structured responses
* Handle HTTP errors

Forbidden:

* Graph construction
* Scoring logic
* SQL queries

API must call application services only.

---

## ğŸ”¹ 4.3 Application Layer (application/)

This is orchestration.

Responsibilities:

* Execute full analysis workflow
* Call parser bridge
* Construct graph
* Trigger scoring
* Persist results
* Return structured result object

It coordinates.

It does not contain business formulas.

---

## ğŸ”¹ 4.4 Domain Layer (domain/)

This is your intellectual core.

Contains:

* Graph model logic
* Risk scoring math
* Extraction scoring math
* Blast radius
* Centrality wrappers

This layer must:

* Be framework-independent
* Have zero FastAPI imports
* Have zero SQLite imports
* Be fully unit-testable

This is what makes your project academically strong.

---

## ğŸ”¹ 4.5 Infrastructure Layer (infrastructure/)

Handles:

* PHP subprocess execution
* File scanning
* Database connection
* Repository implementations
* Configuration

It must not contain scoring logic.

---

# 5ï¸âƒ£ Dependency Rules (Non-Negotiable)

Allowed:

* API â†’ Application
* Application â†’ Domain
* Application â†’ Infrastructure
* Infrastructure â†’ Domain models (only simple data types)

Forbidden:

* Domain importing Infrastructure
* Domain importing FastAPI
* Infrastructure importing API
* UI importing Domain

---

# 6ï¸âƒ£ Domain Model Design

Inside domain/models:

### node.py

Defines:

* Node dataclass
* NodeType enum
* NodeMetrics object

### edge.py

Defines:

* Edge dataclass
* EdgeType enum

### graph_model.py

Encapsulates:

* add_node()
* add_edge()
* compute_degrees()
* resolve_placeholders()

Graph operations live here.

---

# 7ï¸âƒ£ Scoring Isolation

In:

```
domain/scoring/
```

We define:

risk_calculator.py
extraction_calculator.py

These must:

* Accept graph object
* Return mapping of node_id â†’ score
* Have zero side effects

No DB writes.
No file writes.

Pure functions.

This ensures:

* Reproducibility
* Unit test clarity
* Mathematical transparency

---

# 8ï¸âƒ£ Application Layer Flow

analysis_service.py should contain:

```id="appflow"
class AnalysisService:

    def run_analysis(self, project_name, root_path, options):
        files = file_scanner.scan(root_path)
        ast_data = parser_bridge.parse_files(files)
        graph = graph_builder.build(ast_data)
        metrics = metric_engine.compute(graph)
        risk = risk_calculator.compute(graph)
        extraction = extraction_calculator.compute(graph)
        persistence.save(...)
        return summary
```

It orchestrates.

It does not implement formulas.

---

# 9ï¸âƒ£ Repository Pattern (Critical for Clean Persistence)

Inside infrastructure/persistence/repositories.py:

Define:

* ProjectRepository
* AnalysisRunRepository
* ComponentRepository
* EvaluationRepository

Application layer calls repositories via interfaces.

This prevents tight DB coupling.

---

# ğŸ”Ÿ Configuration Management

Inside infrastructure/config.py:

* Read env variables
* Define DB path
* Define data folder
* Define limits

Never hardcode file paths.

---

# 11ï¸âƒ£ Testing Strategy Integration

Each layer must be testable independently:

| Layer          | Test Type             |
| -------------- | --------------------- |
| Domain         | Unit tests            |
| Application    | Integration tests     |
| API            | Endpoint tests        |
| Infrastructure | Subprocess mock tests |

Domain layer should reach 90%+ coverage.

---

# 12ï¸âƒ£ Anti-Patterns to Avoid

ğŸš« Putting scoring logic inside API routes
ğŸš« Calling SQLite directly from domain
ğŸš« Letting UI manipulate graph
ğŸš« Passing raw JSON everywhere
ğŸš« Global mutable state

---

# 13ï¸âƒ£ Future Collaboration Safety

When new members join:

* Member 1 â†’ PHP parser improvements
* Member 2 â†’ Domain scoring refinement
* Member 3 â†’ UI enhancements

Because boundaries are clear, they wonâ€™t break each otherâ€™s code.

---

# 14ï¸âƒ£ Why This Blueprint Is Strong

It:

* Enforces clean layering
* Prevents technical debt
* Supports unit testing
* Enables scalability
* Supports academic validation
* Makes refactoring safe

Most FYP systems collapse because they skip this.

Yours will not.

---

# ğŸš€ Where You Stand Now

You now have:

1. Charter
2. Canonical AST schema
3. Graph model
4. Risk & extraction specification
5. API specification
6. Persistence & ER design
7. Implementation architecture blueprint

At this point:

You are ready to start coding with zero ambiguity.

---

# ğŸ”¥ Next Step (Very Important)

Before coding begins:

You must define:

# ğŸ‘‰ Phase-Based Development Plan (Implementation Execution Order)

Not weeks.

Phases based on system dependency chain.

If you want, I will now create:

* Phase 1: Minimal Vertical Slice
* Phase 2: Core Intelligence
* Phase 3: Evaluation Engine
* Phase 4: Optimization & Hardening
* Phase 5: Demonstration & Validation
