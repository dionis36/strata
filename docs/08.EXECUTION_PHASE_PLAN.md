Excellent. Below is the **fully revised and strengthened** version of your execution phase plan, aligned with:

* Correct intelligence sequencing
* Research defensibility
* Experimental isolation
* Clean architectural layering
* Clear Git milestone tagging

This replaces your previous version.

---

# üìò EXECUTION PHASE PLAN ‚Äî REVISED & RESEARCH-ALIGNED

---

# üéØ OVERARCHING PRINCIPLE

Each phase must:

* Produce a runnable system
* Introduce only one intelligence layer
* Preserve architectural integrity
* End with a Git tag
* Be experimentally isolatable

No mixing of intelligence layers.

No premature optimization.

---

# üß± PHASE 0 ‚Äî FOUNDATION & INFRASTRUCTURE LOCK-IN

## Objective

Establish a stable, reproducible, layered architecture.

## Includes

* Folder structure
* Docker environment
* SQLite initialization
* Health endpoint
* Streamlit health UI
* Logging
* Basic test setup
* Git initialization + baseline tag

## Must NOT Include

* AST logic
* Graph logic
* Scoring logic

## Exit Criteria

* `docker compose up` works cleanly
* `/health` returns OK
* DB auto-creates and persists
* Tests pass
* Tag created:
  `v0.1-foundation`

---

# üîÑ PHASE 1 ‚Äî MINIMAL VERTICAL SLICE

## Objective

Prove end-to-end architecture flow with minimal intelligence.

## Pipeline

Upload files ‚Üí Parse minimally ‚Üí Build minimal graph ‚Üí Store run ‚Üí Return metrics ‚Üí Display in UI

## Includes

* Basic PHP file ingestion
* Minimal AST extraction (class + method + call detection)
* Directed graph construction (NetworkX)
* Graph JSON serialization
* Persist run metadata (not full graph relationally)
* `/analyze` endpoint
* UI display of:

  * file count
  * class count
  * edge count

## Must NOT Include

* Centrality
* Risk scoring
* DB write detection
* Extraction ranking
* Visualization

## Exit Criteria

* Analysis runs twice without corruption
* Separate JSON per run
* Failures handled gracefully
* Tag created:
  `v0.2-vertical-slice`

---

# üß† PHASE 2 ‚Äî STRUCTURAL GRAPH INTELLIGENCE

## Objective

Validate structural correctness of the system.

This phase introduces measurable structural intelligence.

## Includes

### Graph Metrics

* In-degree
* Out-degree
* Weighted degree
* Betweenness centrality
* Strongly connected components
* Blast radius
* Coupling indicators

### Persistence

* Metric storage in SQLite
* Extend schema to store component metrics

### API

* `/metrics/{run_id}` endpoint

## Must NOT Include

* Risk scoring
* Classification
* DB write detection
* Extraction ranking

## Why Isolation Matters

Structural correctness must be validated before applying scoring assumptions.

This phase allows:

* Metric verification
* Sensitivity checks
* Graph validation

## Exit Criteria

* Metrics stable across repeated runs
* No graph inconsistencies
* Structural metrics persisted
* Tag created:
  `v0.3-structural-metrics`

---

# üìä PHASE 3 ‚Äî STRUCTURED DETERMINISTIC RISK FRAMEWORK

## Objective

Transform validated structural metrics into a formal, explainable, deterministic risk model.

This phase does **not** introduce new structural intelligence.
It introduces **interpretation logic** over the frozen structural feature space produced in Phase 2.

The outcome is a mathematically documented, reproducible risk formulation.

---

## Architectural Principle

Risk modeling must be:

* Deterministic
* Explainable
* Layered
* Experimentally isolatable
* Independent of future behavioral layers

No machine learning.
No black-box scoring.
No modification of structural metrics.

---

## Phase 3 Internal Architecture

### 1Ô∏è‚É£ Feature Normalization Layer

Raw structural metrics are transformed into normalized feature vectors.

Examples:

* Normalized betweenness
* Normalized blast radius
* Normalized in-degree / out-degree
* Normalized coupling strength

All normalization functions must be:

* Deterministic
* Documented
* Stable across repeated runs

Output:

```
Component ‚Üí Structural Feature Vector
```

---

### 2Ô∏è‚É£ Structural Feature Engineering Layer

Derived structural indicators are introduced to capture architectural meaning.

Examples:

* **Structural Criticality Index**
  (Betweenness √ó Blast Radius)

* **Instability Indicator**
  (Out-degree / (In-degree + Out-degree))

* **Cycle Vulnerability Flag**
  (SCC size > 1)

* **Coupling Pressure Indicator**

These features are deterministic transformations of Phase 2 outputs.

No new graph logic is introduced.

---

### 3Ô∏è‚É£ Risk Composition Engine

Risk is computed using a structured formulation rather than a flat weighted sum.

The model consists of:

* Base Structural Risk
* Criticality Amplification
* Instability Penalty
* Cycle Penalty

Conceptual structure:

```
BaseRisk
+ Œ±(CriticalityIndex)
+ Œ≤(InstabilityIndicator)
+ Œ≥(CyclePenalty)
```

Where:

* Œ±, Œ≤, Œ≥ are explicitly documented coefficients
* All terms are explainable
* Risk ‚àà [0,1]

The formulation must be:

* Mathematically documented
* Version-controlled
* Stable under repeated execution

---

### 4Ô∏è‚É£ Risk Classification Layer

Continuous risk scores are transformed into interpretable categories:

* Low Risk
* Medium Risk
* High Risk
* Critical

Classification is percentile-based to preserve comparability across systems of different sizes.

---

## Persistence

Extend schema to store:

* Normalized feature values
* Derived structural indicators
* Final risk score
* Risk classification

No behavioral or DB-write attributes included in this phase.

---

## API

* `/risk/{run_id}` endpoint
* Returns:

  * Risk score
  * Risk level
  * Underlying structural contributors

---

## UI

* Risk ranking table
* Expandable component-level explanation view
* Display of contributing structural factors

---

## Why This Structured Approach Matters

This enables:

* Ablation studies in Phase 6
* Sensitivity analysis of coefficients
* Comparison of additive vs amplified formulations
* Research defensibility
* Full explainability of every risk value

Risk is not a compression of metrics.
It is a formal interpretation layer.

---

## Must NOT Include

* DB write detection
* Table nodes
* Behavioral intelligence
* Extraction ranking
* Performance optimization

This phase operates strictly on Phase 2 structural outputs.

---

## Exit Criteria

* Risk values deterministic across repeated runs
* Risk ‚àà [0,1]
* Feature engineering layer documented
* Coefficients version-controlled
* Classification stable
* Tag created:
  `v0.4-risk-framework`

---

# üß™ PHASE 4 ‚Äî BEHAVIORAL INTELLIGENCE (DB WRITE DETECTION)

## Objective

Introduce behavioral context into structural risk.

## Includes

### Static Analysis Enhancements

* SQL write detection (INSERT, UPDATE, DELETE)
* Table name extraction
* Write-frequency attribution
* Table-node creation in graph

### Behavioral Metrics

* Write intensity score
* DB centrality indicator

### Integration

* Risk multiplier adjustment

## Why This Phase Is Separate

Behavioral analysis is a second intelligence dimension.
It must be measured independently before integration.

Allows:

* Structural-only vs structural+behavior comparison

## Exit Criteria

* Writes correctly detected
* False positives minimized
* Risk shifts measurable
* Tag created:
  `v0.5-behavioral-intelligence`

---

# üèó PHASE 5 ‚Äî EXTRACTION INTELLIGENCE & SIMULATION

## Objective

Rank modernization candidates using validated intelligence.

## Includes

### Extraction Model

* Cohesion proxy
* Extraction score formula
* Ranking algorithm
* Core-node protection rule

### Simulation

* Node removal simulation
* Impact estimation

### API

* `/extraction/{run_id}` endpoint

### UI

* Ranked extraction candidates

## Why It Comes Last

Extraction depends on:

* Structural intelligence
* Risk model
* Behavioral context

Without validated upstream layers, ranking is arbitrary.

## Exit Criteria

* Ranked candidates produced
* Stable ordering
* Simulation reproducible
* Tag created:
  `v0.6-modernization-engine`

---

# üìà PHASE 6 ‚Äî EVALUATION & SENSITIVITY ANALYSIS

## Objective

Validate academic claims.

## Includes

* Precision/Recall
* F1 score
* Weight perturbation experiments
* Ground truth comparison
* Ablation studies

## Deliverable

* Evaluation report
* Charts
* Statistical stability analysis

## Exit Criteria

* Quantified performance metrics
* Sensitivity documented
* Tag created:
  `v0.7-evaluation-ready`

---

# ‚ö° PHASE 7 ‚Äî PERFORMANCE & HARDENING

## Objective

Improve efficiency without changing intelligence logic.

## Includes

* Parallel parsing
* Caching
* Memory optimization
* Profiling

## Must NOT Modify

* Risk formulas
* Extraction formulas

## Exit Criteria

* Runtime improvements measurable
* Memory stable
* Tag created:
  `v0.8-performance-stable`

---

# üé¨ PHASE 8 ‚Äî DEMO & FINALIZATION

## Objective

Polish and finalize for submission.

## Includes

* Graph visualization
* UI polish
* Export functionality
* Documentation finalization

## Exit Criteria

* Demo-ready system
* Reproducible evaluation
* Tag created:
  `v1.0-final`

---

# üî¨ RESEARCH STRENGTH ADVANTAGE OF THIS STRUCTURE

This phase design allows:

* Clear thesis chapter mapping
* Clean experimental layering
* Isolated intelligence validation
* Ablation study credibility
* Sensitivity analysis clarity

Each intelligence layer is independently testable.

---

# üîê STRICT PHASE RULE

You cannot introduce logic from a future phase early.

Violations destroy experimental clarity.

---

# üß† FINAL STRATEGIC NOTE

You are not just building software.

You are constructing:

* A layered research artifact
* A defensible experimental framework
* A reproducible modernization intelligence system

Sequence determines strength.

---

If you want next, we can:

* Convert this into a Git milestone + branch strategy map
* Map this to thesis chapter structure
* Design Phase 2 structural metric implementation blueprint
* Or stress-test the risk model design mathematically

Your move.
