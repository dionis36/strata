# ðŸ“„ ARTIFACT #8 â€” Phase-Based Execution Plan

Save as:
`/docs/EXECUTION_PHASE_PLAN.md`

---

# âš ï¸ First Principle

Each phase must end with:

* A runnable system
* Version tag
* Clear measurable milestone
* Zero broken contracts

No half-finished architectural layers.

---

# PHASE 0 â€” Environment & Skeleton (Foundation Lock-In)

## Objective

Create the structural skeleton without intelligence.

## Deliverables

* Folder structure exactly as defined
* Dockerfile (minimal working)
* FastAPI `/health`
* Streamlit app showing â€œSystem Readyâ€
* SQLite database initialization
* Logging system configured
* CI workflow running basic tests

## Absolutely No:

* Graph logic
* Risk scoring
* Parser logic

## Why This Phase Exists

You are locking:

* Dependency boundaries
* Docker reproducibility
* Dev workflow
* Test harness

If this is unstable later â†’ everything slows down.

---

## Exit Criteria

* `docker compose up` runs successfully
* `/health` returns OK
* Database file created
* CI pipeline passes

Tag: `v0.1-foundation`

---

# PHASE 1 â€” Minimal Vertical Slice (AST â†’ Graph â†’ API â†’ UI)

## Objective

End-to-end path using 3â€“5 small PHP fixture files.

Not performance.
Not scoring sophistication.
Just structural correctness.

---

## Components Implemented

### Infrastructure

* parser_bridge.py (single file support)
* file_scanner.py

### Domain

* GraphModel class
* Basic node & edge creation
* Degree calculation

### Application

* analysis_service.run_analysis()

### API

* `/analysis/start`
* `/analysis/{id}/result`

### UI

* Button â†’ run analysis
* Display total nodes & edges

---

## No:

* Risk scoring
* Centrality
* DB detection sophistication
* Extraction ranking
* Persistence beyond summary

---

## Why Critical?

This proves:

AST JSON â†’ Python â†’ Graph â†’ API â†’ UI

If this chain breaks later, debugging is manageable because system is small.

---

## Exit Criteria

* Analyze test fixtures
* Graph JSON generated
* UI displays correct node count
* No crashes on parse error

Tag: `v0.2-vertical-slice`

---

# PHASE 2 â€” Structural Intelligence (Core Graph Analytics)

Now we add intelligence.

## Objective

Make graph analytical, not decorative.

---

## Implement

* Weighted edges
* Betweenness centrality
* Blast radius computation
* DB table node creation
* Weighted in/out degree

---

## Integrate

* Risk scoring formula
* Percentile classification
* Risk stored in DB

---

## UI

* Display risk heat map
* Show top 10 high-risk nodes

---

## Absolutely No

* Extraction ranking yet
* Sensitivity analysis
* Optimization

---

## Exit Criteria

* Risk score reproducible across runs
* Percentile classification stable
* Manual validation on small dataset

Tag: `v0.3-structural-intelligence`

---

# PHASE 3 â€” Extraction Intelligence & Simulation

Now modernization capability.

---

## Implement

* Cohesion proxy
* DB isolation score
* Extraction scoring formula
* Ranking algorithm
* Simulation endpoint

---

## UI

* Table sorted by extraction_score
* â€œSimulate removalâ€ button
* Blast radius visual feedback

---

## Critical Guard

Implement â€œCore Node Protectionâ€ rule:

If risk > 80th percentile AND blast radius high â†’ not recommended.

---

## Exit Criteria

* Top 5 extraction candidates reasonable
* Simulation returns deterministic results
* Scores consistent across reruns

Tag: `v0.4-modernization-engine`

---

# PHASE 4 â€” Evaluation Engine & Academic Rigor

Now we strengthen the academic backbone.

---

## Implement

* EvaluationLabel table
* Precision/Recall computation
* F1 score calculation
* Sensitivity analysis script
* Weight perturbation experiment

---

## Produce

* Evaluation report JSON
* Comparison between runs

---

## UI (optional)

* Display precision/recall metrics

---

## Exit Criteria

* Documented evaluation results
* Reproducible experiments
* Weight sensitivity graph

Tag: `v0.5-evaluation-ready`

---

# PHASE 5 â€” Performance & Hardening

Now we optimize.

---

## Implement

* Parallel file parsing
* Caching via project hash
* Lazy centrality computation
* Memory guards
* Timeout per file
* Vendor exclusion optimization

---

## Test

* 1000+ file project
* Measure runtime
* Profile memory

---

## Exit Criteria

* Under target performance benchmark
* Stable under repeated runs
* No memory explosion

Tag: `v0.6-performance-stable`

---

# PHASE 6 â€” Demonstration & Finalization

Now polish.

---

## Implement

* Export CSV
* Export JSON
* Generate summary report
* Clean UI improvements
* Final Docker cleanup
* Full documentation pass

---

## Produce

* Demo dataset
* Demonstration script
* Final system diagram
* Screenshots for report

---

## Exit Criteria

* One-command demo
* Supervisor-friendly interface
* Clear explanation of results

Tag: `v1.0-final`

---

# Critical Execution Discipline Rules

1. Never start next phase before tagging current one.
2. Never refactor architecture mid-phase.
3. Each phase must produce something demoable.
4. No feature creep during a phase.
5. Every new formula must have unit tests.

---

# Why This Plan Is Strong

It:

* Minimizes rework
* Builds intelligence gradually
* Preserves architectural integrity
* Protects academic rigor
* Avoids premature optimization
* Reduces collaboration conflict later

---

# Where You Are Now

You have:

* Architecture defined
* Data contracts defined
* Analytical model defined
* Storage defined
* API defined
* Execution plan defined

This is no longer an idea.

This is a system blueprint.

---

# Final Question (Critical Strategic Choice)

Before coding begins:

Do you want to start with:

A) Implementing Phase 0 practically (I guide you file-by-file)
B) Designing unit test scaffolding first (test-first discipline)
C) Writing the core domain graph model first (intellectual core first)

Choose one.

Be deliberate.
